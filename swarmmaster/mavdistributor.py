from .swarmclient import SwarmClient
from .onedrone import * #generated by mavgenerate //custom dialect
from .swarmmanager import SwarmManager
from .udpserver import UDPServer
from .udplistener import UDPListener

import logging
import threading

logger = logging.getLogger(__name__)

#from pymavlink.dialects.v20 import ardupilotmega as mavlink2

class Mavdistributor(threading.Thread):
    
    def __init__(self, udpserver: UDPServer,udplistener: UDPListener, swarmmanager: SwarmManager):
        self.output = open('mavdistributor.log','wb')
        self.mav = MAVLink(self.output)
        self.mav.robust_parsing= True
        self.udp_server = udpserver
        self.udp_listener = udplistener
        self.client = None
        self.swarmmanager = swarmmanager
        self.keep_running = False
        self.sequence = 0
        threading.Thread.__init__(self)
    
    def __del__(self):        
        self.output.close()

    def run(self):
        self.keep_running = True
        mav = self.mav
        us= self.udp_server
        logging.info('MAVDIST | Starting MAVDistributor')
        while self.keep_running:
            if self.udp_server.data_available:
                us.rx_lock.acquire()
                mav.buf += us.rx_buf[:]
                us.rx_buf.clear()
                us.data_available =False
                us.rx_lock.release()
                self.parse_mav_udp_buffer()
            if self.udp_listener.data_available:
                self.forward_rtcm_from_udp_to_broadcast()
            else:
                time.sleep(0.1)
        logging.info('MAVDIST | MAVDistributor is ending')
        
    def stop(self):
        self.keep_running = False
        self.join()    
    def forward_rtcm_from_udp_to_broadcast(self):
        self.udp_listener.rx_lock.acquire()
        data=self.udp_listener.rx_buf[:]
        self.udp_listener.rx_buf.clear()
        self.udp_listener.data_available=False
        self.udp_listener.rx_lock.release()
        self.swarmmanager.broadcast_client.add_data_to_tx_buffer(data)

    def wrap_data_from_udp_listener_into_mavlink_and_send_to_broadcast(self):
        self.udp_listener.rx_lock.acquire()
        data=self.udp_listener.rx_buf[:]
        self.udp_listener.rx_buf.clear()
        self.udp_listener.data_available=False
        self.udp_listener.rx_lock.release()
        size= len(data)
        max_len=180

        total_msgs = int(size/max_len)+1

        if total_msgs >4:
            #capacity of mavlink RTCM protocol is exceeded. drop all. 
            logger.warning(f"MAVDISTRIBUTOR | Dropping {size} bytes of RTCM data because MAVLINK protocol spec is exceeded")

        elif total_msgs ==1:
            #send non-fragmented message
            flags=0
            flags |= self.sequence <<3
            payload=data
            self.sequence =(self.sequence+1) % 0x1f
            mavlink_msg=self.mav.gps_rtcm_data_encode(flags,len(payload),payload)
            mavlink_data = mavlink_msg.pack(self.mav)
            self.swarmmanager.broadcast_client.add_data_to_tx_buffer(mavlink_data)

        else:
            #send fragmented message
            fragment_id = 0
            for msg_id in range(total_msgs):
                flags=0x1
                flags |= fragment_id <<1
                fragment_id +=1
                flags |= self.sequence <<3
                self.sequence =(self.sequence+1) % 0x1f

                payload = data[:180]
                data =data[180:]
                mavlink_msg=self.mav.gps_rtcm_data_encode(flags,len(payload),payload)
                mavlink_data = mavlink_msg.pack(self.mav)
                self.swarmmanager.broadcast_client.add_data_to_tx_buffer(mavlink_data)

            if fragment_id <=4 :
                # final message required
                flags=0x1
                flags |= fragment_id <<1
                flags |= self.sequence <<3
                self.sequence =(self.sequence+1) % 0x1f
                payload = b''
                mavlink_msg=self.mav.gps_rtcm_data_encode(flags,len(payload),payload)
                mavlink_data = mavlink_msg.pack(self.mav)
                self.swarmmanager.broadcast_client.add_data_to_tx_buffer(mavlink_data)

    def parse_mav_udp_buffer(self):
        continue_parsing = True
        old_buf_index = 0
        while continue_parsing:
            try:
                msg = self.mav.parse_char('')
                if msg:
                    self.handle_mav_udp_msg(msg)
                elif msg ==None :
                    if self.mav.buf_index and (old_buf_index != self.mav.buf_index) : 
                        logger.warning(f'MAVDISTRIBUTOR | Dropping bad data because of No MAVLINK Message:{self.mav.buf[old_buf_index]}')

            except MAVError:
                self.mav.buf_index =old_buf_index + 1
                logger.warning(f'MAVDISTRIBUTOR | Dropping bad data because of MAVError:{self.mav.buf[old_buf_index]}')

            #check if end condition is met
            if old_buf_index == self.mav.buf_index: 
                continue_parsing= False
            else:
                old_buf_index = self.mav.buf_index
        
    def handle_mav_udp_msg(self, msg):
        try:
            logger.debug(f'MAVDISTRIBUTOR | Handling incoming udp messsage {msg.to_json()}')
            msg_dict = msg.to_dict()
            if msg_dict['mavpackettype']=="HEARTBEAT":
                logger.debug("MAVDISTRIBUTOR | Received HEARTBEAT msg")
            elif msg_dict['mavpackettype']=="GPS_RTCM_DATA":
                # try:
                #     self.swarmmanager.clients[4].add_data_to_tx_buffer(msg.get_msgbuf())
                # except:
                #     self.swarmmanager.broadcast_client.add_data_to_tx_buffer(msg.get_msgbuf())
                self.swarmmanager.broadcast_client.add_data_to_tx_buffer(msg.get_msgbuf())

                logger.debug(f"MAVDISTRIBUTOR | Received GPS_RTCM_DATA {msg.to_json()}")
            elif msg_dict['mavpackettype']=="MISSION_SYNC_REL":
                self.swarmmanager.broadcast_client.add_data_to_tx_buffer(msg.get_msgbuf())
                logger.debug(f"MAVDISTRIBUTOR | Received MISSION_SYNC_REL msg {msg_dict['rel_time']/1000}")
            elif 'target_system' in msg_dict.keys():
                target_system = msg_dict['target_system']
                if self.swarmmanager.is_client(target_system):
                    client = self.swarmmanager.get_client(target_system)
                    client.add_data_to_tx_buffer(msg.get_msgbuf())
                else :
                    logger.warn(f'MAVDISTRIBUTOR | Received Message for Not Registered Client #{target_system:04x}. Message is beeing dropped')
                    logger.warn(f'MAVDISTRIBUTOR | Message : {msg.to_json()}')
        except KeyError:
            logger.debug(f'MAVDISTRIBUTOR | Keyerror in handle_mav_udp_msg')  
            logger.debug(f'MAVDISTRIBUTOR | Message is {msg.to_json()}') 



            
